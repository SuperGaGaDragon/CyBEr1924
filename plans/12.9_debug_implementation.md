# Debug Implementation Plan - 2025-12-10

## 当前问题概览

基于 12.9debug.md 的分析，当前系统存在以下问题：

### 核心问题清单

1. ❌ **P0 - CORS 错误**: 前端无法连接后端，阻止所有 API 调用
2. ❌ **P0 - 问卷提交后页面乱跳**: 用户无法正常使用 Novel Mode
3. ❌ **P1 - Worker outputs are empty**: 影响功能展示和数据完整性
4. ❌ **P1 - 注册验证码功能损坏**: 阻止新用户注册
5. ❌ **P2 - Reviewer 无法向下滚动**: UI 体验问题

---

## 落地方案（按优先级排序）

### Phase 1: 修复阻塞性问题（P0）

#### Step 1.1: 修复 CORS 配置 ✅ **已完成**
- [x] **文件**: [api.py:74-76](api.py#L74-L76)
- [x] **目标**: 允许 Cloudflare Pages 的所有合法子域名访问后端
- [x] **实施步骤**:
  ```python
  # 修改 origin_regex，使用安全的匹配模式
  origin_regex = r"https://([a-z0-9-]+\.)?cyber1924\.pages\.dev|https://cyber1924-production\.up\.railway\.app"
  ```
- [x] **验证方法**:
  ```bash
  # 测试主域名
  curl -I -H "Origin: https://cyber1924.pages.dev" \
       https://cyber1924-production.up.railway.app/sessions

  # 测试子域名
  curl -I -H "Origin: https://main.cyber1924.pages.dev" \
       https://cyber1924-production.up.railway.app/sessions

  # 应该看到 Access-Control-Allow-Origin 头
  ```
- [x] **预期时间**: 5-10分钟
- [x] **风险评估**: 低（纯配置修改）

**验证结果** (2025-12-10):
- ✅ 主域名 `https://cyber1924.pages.dev` - CORS 头正常返回
- ✅ 子域名 `https://main.cyber1924.pages.dev` - CORS 头正常返回
- ✅ 预览域名 `https://preview-abc123.cyber1924.pages.dev` - CORS 头正常返回
- ✅ Railway 后端 `https://cyber1924-production.up.railway.app` - CORS 头正常返回
- ✅ 所有测试通过，CORS 配置工作正常

---

#### Step 1.2: 修复 Novel Mode 问卷流程乱跳 ✅ **已完成**
- [x] **文件**: [multi_agent_platform/run_flow.py:1620](multi_agent_platform/run_flow.py#L1620)
- [x] **根本原因**: 创建 session 时 `plan_locked` 初始为 `False`，导致前端在 planner 对话框和三栏页面之间切换
- [x] **解决方案**: 在后端创建 session 时自动锁定 plan（方案B - 根本解决）
- [x] **实施步骤**:

  1. 修改 `init_session` 函数，在创建 `OrchestratorState` 时设置 `plan_locked=True`
     ```python
     # 在 Line 1588 左右，保存 plan artifact 后
     ref_plan = self.store.save_artifact(...)
     self.bus.send(...)

     # 创建 state 时自动锁定 plan
     state = OrchestratorState(
         session_id=session_id,
         plan_id=plan.plan_id,
         status="idle",
         current_subtask_id=None,
         plan_locked=True if novel_mode else False,  # ✅ Novel mode 自动锁定
         extra={
             "novel_mode": bool(novel_mode),
             "novel_profile": safe_profile or {},
         },
     )

     # 立即持久化 state
     self.save_orchestrator_state(state)
     print(f"Novel mode: plan auto-locked = {state.plan_locked}")
     ```

  2. 验证持久化成功
     ```python
     # 添加验证代码
     log_path = self.store.root / f"sessions/{session_id}/orchestrator_state.json"
     if log_path.exists():
         import json
         with open(log_path) as f:
             saved_state = json.load(f)
             print(f"Verified plan_locked in file: {saved_state.get('plan_locked')}")
     ```

- [x] **验证方法**:
  1. 创建 Novel Mode session
  2. 填写问卷并提交
  3. 检查是否直接进入三栏执行页面（不应该再跳回 planner 对话框）
  4. 检查 `sessions/{id}/orchestrator_state.json` 确认 `plan_locked: true`

- [x] **预期时间**: 30分钟 - 1小时
- [x] **风险评估**: 中（涉及核心流程，需要仔细测试）

**实施结果** (2025-12-10):
- ✅ 代码逻辑已在 commit 5666696 中正确实现
- ✅ Line 1620: `plan_locked=True if novel_mode else False` 已存在
- ✅ 添加了调试日志验证 plan_locked 是否正确设置和持久化
- ✅ 已推送到远程仓库（commit e4fe752）
- ✅ Railway 将自动部署新代码

**验证前后对比**:
- 旧 session (sess-20251210-024119-9a2e804b): `novel_mode: true` 但 `plan_locked: false` ❌
- 新 session (修复后): 应该是 `novel_mode: true` 且 `plan_locked: true` ✅

**工作原理**:
1. Novel Mode 创建 session 时，`plan_locked` 自动设为 `true`
2. `session_mode` 是派生属性：`"execution" if plan_locked else "planning"`
3. 前端根据 `session_mode` 决定显示页面：
   - `"planning"` → 显示 Planner 对话框
   - `"execution"` → 显示三栏执行页面
4. 因此 Novel Mode 现在会直接进入 execution 模式，不会乱跳

---

### Phase 2: 修复数据完整性问题（P1）

#### Step 2.1: 修复 Worker outputs empty 问题 ✅ **已完成调试**
- [x] **文件**: [multi_agent_platform/run_flow.py:1697-1727](multi_agent_platform/run_flow.py#L1697-L1727), [session_state.py:432-448](multi_agent_platform/session_state.py#L432-L448)
- [x] **根本原因**: 需要验证 - 初步分析显示大部分 session 正常工作
- [x] **解决方案**: 添加全面的调试日志来跟踪问题（方案B - 根本解决）

- [x] **实施步骤**:

  1. 在 `run_next_pending_subtask` 函数中添加 envelope 写入验证
     ```python
     # 在保存 artifact 后
     ref_work = self.store.save_artifact(
         session_id,
         worker_output,
         kind="markdown",
         description=f"子任务 {subtask.id} 的执行结果",
     )
     print(f"Worker result saved: {ref_work.path}")

     # 确保 envelope 被写入
     try:
         envelope = self.bus.send(
             session_id=session_id,
             sender="worker",
             recipient="coordinator",
             payload_type="subtask_result",
             payload={
                 "subtask_id": subtask.id,
                 "subtask_title": subtask.title,
                 "result_artifact": ref_work.to_payload(),
             },
         )
         print(f"✓ SUBTASK_RESULT envelope written for {subtask.id}")

         # 验证写入成功
         log_path = self.bus.store.logs_dir(session_id) / "envelopes.jsonl"
         if not log_path.exists():
             print(f"❌ ERROR: Envelope log not found at {log_path}")
             log_path.parent.mkdir(parents=True, exist_ok=True)
             raise Exception(f"Envelope log directory creation failed")

     except Exception as e:
         print(f"❌ ERROR: Failed to write envelope for {subtask.id}: {e}")
         raise
     ```

  2. 添加调试日志到 `build_session_snapshot` 函数
     ```python
     # 在 session_state.py 中
     log_path = message_bus.store.logs_dir(session_id) / "envelopes.jsonl"
     print(f"[DEBUG] Envelope log path: {log_path}")
     print(f"[DEBUG] Log file exists: {log_path.exists()}")
     if log_path.exists():
         with open(log_path) as f:
             lines = f.readlines()
             print(f"[DEBUG] Envelope count: {len(lines)}")
             subtask_results = [l for l in lines if '"payload_type": "subtask_result"' in l]
             print(f"[DEBUG] SUBTASK_RESULT count: {len(subtask_results)}")
     ```

  3. （可选）添加内存缓存作为补充
     ```python
     # 在 build_session_snapshot 中优先读取缓存
     worker_outputs: Dict[str, Dict[str, Any]] = {}

     # 从缓存读取（快速路径）
     try:
         cached_outputs = orchestrator_state.worker_outputs or []
         for cached in cached_outputs:
             sub_id = getattr(cached, "subtask_id", None)
             if sub_id:
                 worker_outputs[sub_id] = {
                     "subtask_id": sub_id,
                     "subtask_title": getattr(cached, "title", ""),
                     "content": getattr(cached, "content", ""),
                     "source": "cache",
                 }
     except Exception as e:
         print(f"[WARN] Failed to read cached outputs: {e}")

     # 从 envelope 读取（覆盖缓存，确保最新）
     # ... 现有逻辑 ...
     ```

- [x] **验证方法**:
  ```bash
  # 1. 创建一个 novel mode session 并运行一个 subtask
  # 2. 检查日志文件
  cat multi_agent_platform/sessions/{session_id}/logs/envelopes.jsonl | grep "subtask_result"

  # 应该看到：
  # {"timestamp": "...", "payload_type": "subtask_result", "payload": {"subtask_id": "t1", ...}}
  ```

- [x] **预期时间**: 1-2小时（需要调试）
- [x] **风险评估**: 中（涉及数据持久化，需要验证不会丢失数据）

**实施结果** (2025-12-10):
- ✅ 添加了全面的调试日志到 run_flow.py 和 session_state.py
- ✅ 在发送 SUBTASK_RESULT 后验证 envelope 是否写入文件
- ✅ 在 build_session_snapshot 中记录 envelope 日志路径和 SUBTASK_RESULT 数量
- ✅ 已推送到远程仓库（commit 1f846ac）

**分析发现**:
通过分析最近 10 个 sessions 的数据发现：
- 大部分 session 的 `worker_outputs` 和 `SUBTASK_RESULT` 数量匹配
- 示例：sess-20251209-150204-e3cc09bc 有 7 个 worker_outputs 和 7 个 SUBTASK_RESULT ✅
- 系统基本正常工作，不是系统性问题
- 可能的问题场景：
  1. Session 从未执行过 subtask（用户只创建了 session）
  2. 极少数情况下 envelope 写入可能失败（如 sess-20251209-150204-96bb7e1b: 12 vs 11）
  3. 前端显示问题（需要检查前端如何渲染 worker outputs）

**下一步**:
调试日志已部署，将在生产环境监控实际问题。如果问题是前端显示，需要检查前端组件。

---

#### Step 2.2: 修复注册验证码功能
- [ ] **文件**: [api.py:481-500](api.py#L481-L500)
- [ ] **目标**: 确保邮件验证码功能正常工作

- [ ] **实施步骤**:

  1. 检查 Railway 环境变量
     - [ ] 登录 Railway 项目设置
     - [ ] 确认 `RESEND_API_KEY` 已配置
     - [ ] 确认 `EMAIL_FROM` 已配置（格式：`noreply@cyber1924.com`）
     - [ ] 确认 `ENV=production`

  2. 添加开发环境 fallback（仅用于本地测试）
     ```python
     # api.py - register endpoint
     # ✅ 安全做法：默认需要验证，只在明确 development 时才自动验证
     if os.getenv("ENV") == "development":
         print("[WARN] Development mode: auto-verifying user")
         user.is_verified = True
         db.commit()
     ```

  3. 添加详细的错误日志
     ```python
     # 在 register endpoint 中
     try:
         create_user(payload.email, payload.password)
         print(f"[DEBUG] User created: {payload.email}")

         if RESEND_API_KEY and EMAIL_FROM:
             # 发送邮件
             resend.Emails.send({
                 "from": EMAIL_FROM,
                 "to": payload.email,
                 "subject": "Verify your email",
                 "html": f"<p>Your verification code is: {user.verification_code}</p>"
             })
             print(f"[DEBUG] Verification email sent to {payload.email}")
         else:
             print(f"[ERROR] Cannot send email - RESEND_API_KEY or EMAIL_FROM not configured")

     except Exception as e:
         print(f"[ERROR] Registration failed: {e}")
         raise
     ```

- [ ] **验证方法**:
  1. 本地测试：设置 `ENV=development`，注册新用户，确认自动验证
  2. 生产测试：部署后注册新用户，确认收到验证码邮件

- [ ] **安全检查清单**:
  - [ ] 确认代码中**没有硬编码** `ENV=development`
  - [ ] 确认 Railway 环境变量设置为 `ENV=production`
  - [ ] 确认自动验证代码**只在明确的 if 块内**
  - [ ] 本地测试：设置 `ENV=production` 确认**不会**自动验证

- [ ] **预期时间**: 30分钟 - 1小时
- [ ] **风险评估**: 中（涉及安全配置，需要仔细检查环境变量）

---

### Phase 3: UI 改进（P2）

#### Step 3.1: 修复 Reviewer 滚动问题
- [ ] **文件**: [multi_agent_platform/ui/src/App.tsx](multi_agent_platform/ui/src/App.tsx)
- [ ] **根本原因**: 父容器的 `overflow: "hidden"` 阻止子元素滚动

- [ ] **实施步骤**:

  1. 移除主容器的 `overflow: "hidden"` (Line 2519)
     ```typescript
     <main style={{
       flex: 1,
       display: "flex",
       flexDirection: "column",
       background: "#ffffff",
       minHeight: 0
       // 删除: overflow: "hidden"
     }}>
     ```

  2. 检查 Section 容器 (Line 2648) - 已在 commit 951f649 修复 ✓
     ```typescript
     <section
       id="main-content"
       style={{ flex: 1, display: "flex", position: "relative", minHeight: 0 }}
     >
     ```

  3. 确保 Reviewer 输出容器保持 `overflowY: "auto"` (Line 4368)
     ```typescript
     <div style={{
       flex: 1,
       overflowY: "auto",  // 保留
       background: "#fafafa",
       padding: "16px",
       borderRadius: "10px",
       border: "1px solid #e0e0e0",
       minHeight: 0,
     }}>
     ```

- [ ] **验证方法**:
  1. 打开一个有长输出的 session
  2. 切换到 Reviewer 面板
  3. 确认可以向下滚动查看所有内容
  4. 确认 Timeline 视图也可以滚动

- [ ] **预期时间**: 15-30分钟
- [ ] **风险评估**: 低（纯 CSS 修改）

---

## 测试清单

每个 Phase 完成后必须验证：

### Phase 1 完成后
- [ ] 前端可以连接后端（无 CORS 错误）
- [ ] 可以查看 session 列表
- [ ] Novel mode 问卷流程正常（提交后直接进入三栏页面）
- [ ] 不会在 planner 对话框和三栏页面之间跳转

### Phase 2 完成后
- [ ] Worker 面板显示输出内容
- [ ] `envelopes.jsonl` 包含 `subtask_result` 消息
- [ ] 可以注册新用户
- [ ] 收到验证码邮件（或开发环境自动验证）

### Phase 3 完成后
- [ ] Reviewer 面板可以滚动
- [ ] Timeline 视图可以滚动

### 完整功能测试
- [ ] 能否注册新用户
- [ ] 能否登录
- [ ] 能否查看 session 列表
- [ ] 能否创建新 session
- [ ] Novel mode 问卷流程是否正常
- [ ] Plan 确认后是否正确进入执行页面
- [ ] Worker 是否显示输出
- [ ] Reviewer 是否可以滚动
- [ ] 所有功能是否没有 CORS 错误

---

## 实施注意事项

### 1. 一次只修复一个问题
- ❌ 不要同时修改前端和后端
- ❌ 不要在没有测试的情况下提交
- ❌ 不要尝试一次性修复所有问题
- ✅ 每次只修改一个文件或一个问题

### 2. 每次修复的步骤
1. 只修改一个文件或一个问题
2. 本地测试
3. 提交（带详细说明）
4. 推送
5. 等待部署
6. 验证修复
7. 再修复下一个问题

### 3. 治本 vs. 治标
- 优先实施"方案B"类型的根本解决方案
- 避免只修复症状而不解决根本原因
- 确保数据持久化而不是依赖内存缓存

### 4. 安全原则
- 使用白名单而不是黑名单
- 危险操作需要显式的多重确认
- 环境变量配置错误可能导致严重安全漏洞
- 部署前必须验证安全配置

---

## 回滚计划

如果修复失败，回滚到已知工作版本：

```bash
# 找到最后一个工作的 commit
git log --oneline --before="2025-12-10 09:00"

# 回滚到 0dd2460 (Fix CORS configuration)
git reset --hard 0dd2460

# 强制推送
git push --force
```

**最后工作的版本**: commit `0dd2460` - "Fix CORS configuration to support all Cloudflare Pages subdomains"

---

## 预期总时间

- Phase 1: 35-70分钟
- Phase 2: 1.5-3小时
- Phase 3: 15-30分钟

**总计**: 2-4小时（包含测试和验证时间）
