# Bug 报告和解决方案 - 2025-12-10

## 当前状态概览

### 已确认的问题

1. ❌ **问卷提交后页面乱跳**
2. ❌ **Reviewer 无法向下滚动**
3. ❌ **Worker 显示 "outputs are empty while progress events exist"**
4. ❌ **注册验证码功能损坏**
5. ❌ **CORS 错误 - 前端无法连接后端**

---

## 问题 1: 问卷提交后页面乱跳

### 症状
- 用户填完 Novel Mode 问卷
- 提交后先跳转到三栏页面（Plan/Worker/Reviewer）
- 然后又自动跳回 Planner 对话框
- 再点击确认后又回到三栏页面

### 期望行为
- 提交问卷 → 直接进入 Planner 对话框
- 用户点击 "Confirm Plan" → 进入三栏执行页面
- 不应该在这些状态之间自动跳转

### 根本原因

**文件**: `multi_agent_platform/ui/src/App.tsx`

**问题代码** (Line 1375-1393):
```typescript
// Line 1375-1377: 立即跳转到 session 页面
localStorage.setItem(SESSION_TOKEN_KEY, id);
navigateToSession(id);

setState((prev) => ({
  ...prev,
  loading: true,
  activeSessionId: id,
  snapshot,
}));

// Line 1392-1393: 然后发送 profile，触发 planner 对话
if (createSessionForm.novelMode) {
  await sendNovelProfileToPlanner(id, profileFromResponse as Record<string, any>);
}
```

**问题分析**:
1. `navigateToSession(id)` 立即导航到三栏页面
2. `sendNovelProfileToPlanner()` 调用 `sendCommand(sessionId, "ask", {...})`
3. 这个命令触发 planner 响应，改变 UI 状态
4. UI 根据 `snapshot.plan_locked` 状态在 planner 对话框和三栏页面之间切换

**为什么会跳来跳去**:
- 初始: `plan_locked = false` → 显示 planner 对话框
- 但代码在第1377行已经跳转了 → 显示三栏页面（混乱）
- Planner 处理完 profile → 可能更新 `plan_locked` → 再次改变显示

### 解决方案

**⚠️ 重要**: 方案A只是"治标不治本"，会导致前端状态不稳定。**强烈推荐使用方案B作为主要解决方案**。

**方案 B: 在后端控制流程** (✅ 推荐 - 根本解决方案)

修改后端，让 `createSession` 在 novel_mode 时自动锁定 plan：

```python
# multi_agent_platform/run_flow.py - init_session 函数 (Line 1535-1626)

if safe_profile:
    # ... 创建 t1-t4 任务 ...

    # 验证创建了4个任务
    if len(plan.subtasks) != 4:
        print(f"ERROR: Novel mode requires 4 base tasks, got {len(plan.subtasks)}")
        # ... fallback 逻辑 ...

# 保存 plan artifact (Line 1594-1612)
ref_plan = self.store.save_artifact(...)
self.bus.send(...)

# ⚠️ 关键修复点：创建 state 时设置 plan_locked=True
state = OrchestratorState(
    session_id=session_id,
    plan_id=plan.plan_id,
    status="idle",
    current_subtask_id=None,
    plan_locked=True if novel_mode else False,  # ✅ 在 novel mode 中自动锁定
    extra={
        "novel_mode": bool(novel_mode),
        "novel_profile": safe_profile or {},
    },
)

# ⚠️ 立即持久化 state，确保前端获取 snapshot 时看到正确的状态
self.save_orchestrator_state(state)
print(f"Novel mode: plan auto-locked = {state.plan_locked}")
```

**⚠️ 持久化警告**:
- 必须在 `OrchestratorState` **构造时**就设置 `plan_locked=True`
- 必须**立即调用** `save_orchestrator_state(state)` 持久化
- 如果只在内存中设置，前端获取 snapshot 时仍会看到 `false`
- 验证：修改后启动 session，立即查看 `sessions/{id}/orchestrator_state.json` 确认 `plan_locked: true`

**为什么方案B更好**:
- ✅ 前端收到的snapshot已经是locked状态，不会有状态变化
- ✅ 避免前端异步操作导致的UI闪烁
- ✅ 简化前端逻辑，状态更可预测
- ✅ 后端完全控制流程，更容易维护

**方案 A: 延迟跳转** (⚠️ 不推荐 - 治标不治本)

虽然延迟跳转可以缓解问题，但仍存在隐患：
- ❌ planner 异步响应可能在跳转前/后改变 `plan_locked` 状态
- ❌ 前端需要处理复杂的状态同步逻辑
- ❌ 可能出现竞态条件（race condition）

如果必须使用方案A，需要确保：
1. 等待 `sendNovelProfileToPlanner` 完成
2. 重新获取 snapshot 确认状态
3. 只在状态稳定后才跳转

**推荐实施策略**:
1. 先实施方案B（后端自动锁定）
2. 前端仍然等待响应，但不依赖planner的异步更新
3. 这样即使planner有延迟，前端也能立即显示正确状态

---

## 问题 2: Reviewer 无法向下滚动

### 症状
- Reviewer Output 视图中内容超过屏幕高度
- 无法向下滚动查看更多内容
- Timeline 视图也无法滚动

### 根本原因

**文件**: `multi_agent_platform/ui/src/App.tsx`

**问题**: 父容器的 `overflow: "hidden"` 阻止子元素滚动

**已尝试的修复** (Commit 951f649):
```typescript
// Line 2648: 删除了 overflow: "hidden"
<section
  id="main-content"
  style={{ flex: 1, display: "flex", position: "relative", minHeight: 0 }}
>
```

### 为什么修复无效

虽然删除了一个 `overflow: "hidden"`，但还有其他地方也有这个问题：

**其他有问题的容器**:

1. **Line 2629**: Plan 列的容器
```typescript
<div style={{ flex: 2, minWidth: 0, borderRight: "1px solid #e5e7eb", minHeight: 0, overflow: "hidden" }}>
```

2. **Line 2519**: 主容器
```typescript
<main style={{ flex: 1, display: "flex", flexDirection: "column", background: "#ffffff", minHeight: 0, overflow: "hidden" }}>
```

### 完整解决方案

需要检查整个布局层次结构，确保：
1. 只有**内容容器**有 `overflowY: "auto"`
2. 所有**父容器**不能有 `overflow: "hidden"`

**修复清单**:

```typescript
// 1. 主容器 (Line 2519) - 移除 overflow: "hidden"
<main style={{
  flex: 1,
  display: "flex",
  flexDirection: "column",
  background: "#ffffff",
  minHeight: 0
  // 删除: overflow: "hidden"
}}>

// 2. Section 容器 (Line 2648) - 已修复 ✓
<section
  id="main-content"
  style={{ flex: 1, display: "flex", position: "relative", minHeight: 0 }}
>

// 3. Reviewer 输出容器 (Line 4368) - 保持不变 ✓
<div style={{
  flex: 1,
  overflowY: "auto",  // 这个应该保留
  background: "#fafafa",
  padding: "16px",
  borderRadius: "10px",
  border: "1px solid #e0e0e0",
  minHeight: 0,
}}>
```

---

## 问题 3: Worker outputs are empty while progress events exist

### 症状
- 浏览器控制台警告: "Worker outputs are empty while progress events exist"
- Worker 面板显示 "No progress yet"
- 但实际上任务已经在执行

### 根本原因

**文件**: `multi_agent_platform/session_state.py`

**问题**: `build_session_snapshot` 函数从 `envelopes.jsonl` 读取 worker outputs 时出错

**可能的原因**:

1. **Envelope 日志未写入**
   - `SUBTASK_RESULT` 消息没有被写入 `envelopes.jsonl`
   - 检查 `message_bus.py` 的 `send()` 方法

2. **Artifact 路径错误**
   - Worker 输出被保存，但读取时路径不对
   - 检查 `_read_artifact_content()` 函数

3. **权限问题**
   - Railway 环境可能没有写权限

### 调试步骤

1. **检查 envelopes.jsonl 是否存在**:
```python
# 在 build_session_snapshot 函数开始处添加
log_path = message_bus.store.logs_dir(session_id) / "envelopes.jsonl"
print(f"[DEBUG] Envelope log path: {log_path}")
print(f"[DEBUG] Log file exists: {log_path.exists()}")
if log_path.exists():
    with open(log_path) as f:
        lines = f.readlines()
        print(f"[DEBUG] Envelope count: {len(lines)}")
```

2. **检查 SUBTASK_RESULT 消息**:
```python
# 在 run_flow.py - run_next_pending_subtask 函数中
print(f"[DEBUG] Sending SUBTASK_RESULT for {subtask.id}")
envelope = self.bus.send(
    session_id=session_id,
    sender="worker",
    recipient="coordinator",
    payload_type="subtask_result",
    payload={
        "subtask_id": subtask.id,
        "subtask_title": subtask.title,
        "result_artifact": ref_work.to_payload(),
    },
)
print(f"[DEBUG] Envelope sent: {envelope}")
```

3. **检查 artifact 读取**:
```python
# 在 session_state.py - _read_artifact_content 函数中
def _read_artifact_content(store, path, max_length=None):
    print(f"[DEBUG] Reading artifact: {path}")
    if not path:
        print("[DEBUG] No path provided")
        return ""

    full_path = store.root / path
    print(f"[DEBUG] Full path: {full_path}, exists: {full_path.exists()}")
    # ... 继续
```

### 解决方案

**⚠️ 重要**: 方案A只是"掩盖问题"，在生产环境中可能导致数据丢失。**必须修复envelope写入（方案B）作为主要解决方案**，方案A只作为临时补充。

**方案 B: 修复 envelope 写入** (✅ 推荐 - 根本解决方案)

确保所有 `SUBTASK_RESULT` 消息都被正确写入：

```python
# run_flow.py - run_next_pending_subtask 函数 (Line 1672-1691)

# 在保存 artifact 后立即发送 envelope
ref_work = self.store.save_artifact(
    session_id,
    worker_output,
    kind="markdown",
    description=f"子任务 {subtask.id} 的执行结果",
)
print(f"Worker result saved: {ref_work.path}")

# 确保 envelope 被写入
try:
    envelope = self.bus.send(
        session_id=session_id,
        sender="worker",
        recipient="coordinator",
        payload_type="subtask_result",
        payload={
            "subtask_id": subtask.id,
            "subtask_title": subtask.title,
            "result_artifact": ref_work.to_payload(),
        },
    )
    print(f"✓ SUBTASK_RESULT envelope written for {subtask.id}")

    # 验证写入成功
    log_path = self.bus.store.logs_dir(session_id) / "envelopes.jsonl"
    if not log_path.exists():
        print(f"❌ ERROR: Envelope log not found at {log_path}")
        # 尝试创建目录
        log_path.parent.mkdir(parents=True, exist_ok=True)
        raise Exception(f"Envelope log directory creation failed")

except Exception as e:
    print(f"❌ ERROR: Failed to write envelope for {subtask.id}: {e}")
    # 重要：不要静默失败，应该重新抛出异常或采取补救措施
    raise
```

**为什么方案B必须实施**:
- ✅ envelopes.jsonl 是持久化存储，进程重启后数据仍在
- ✅ 保证数据一致性，避免缓存丢失导致的数据损失
- ✅ 符合事件溯源（Event Sourcing）的最佳实践
- ✅ 便于调试和审计

**方案 A: 强制从 state.worker_outputs 读取** (⚠️ 仅作临时补充)

作为方案B的**补充**（不是替代），可以优先读取缓存：

```python
# session_state.py - build_session_snapshot 函数

# 优先使用缓存（快速路径）
worker_outputs: Dict[str, Dict[str, Any]] = {}

try:
    cached_outputs = orchestrator_state.worker_outputs or []
    for cached in cached_outputs:
        sub_id = getattr(cached, "subtask_id", None)
        if sub_id and sub_id not in worker_outputs:
            # 从缓存构建 worker_output
            worker_outputs[sub_id] = {
                "subtask_id": sub_id,
                "subtask_title": getattr(cached, "title", ""),
                "content": getattr(cached, "content", ""),
                "source": "cache",
            }
except Exception as e:
    print(f"[WARN] Failed to read cached outputs: {e}")

# 然后从 envelope 读取（持久化数据）
# 这会覆盖缓存中的数据，确保最新
for envelope in envelopes:
    if envelope.get("payload_type") == "subtask_result":
        # ... 从 envelope 构建 worker_output ...
        worker_outputs[sub_id] = {
            "source": "envelope",  # 标记来源
            # ...
        }
```

**⚠️ 方案A的局限性**:
- ❌ 内存缓存在进程重启后会丢失
- ❌ Railway/容器环境中进程可能随时重启
- ❌ 无法审计历史数据
- ❌ 只能用作临时缓解，不能作为长期解决方案

**推荐实施策略**:
1. **立即修复** envelope 写入（方案B）
2. 添加详细的错误日志和异常处理
3. 可选：添加缓存作为性能优化（方案A）
4. 监控 envelope 写入失败率

**验证方法**:
修复后，手动检查 envelope 日志：
```bash
# 创建一个 novel mode session 并运行一个 subtask
# 然后检查日志文件
cat multi_agent_platform/sessions/{session_id}/logs/envelopes.jsonl | grep "subtask_result"

# 应该看到类似这样的输出：
# {"timestamp": "...", "payload_type": "subtask_result", "payload": {"subtask_id": "t1", ...}}
```

如果文件不存在或为空，说明 envelope 写入逻辑有问题，需要检查：
- `self.bus.send()` 是否被正确调用
- `session_store.logs_dir()` 路径是否正确
- 文件写入权限是否正常

---

## 问题 4: 注册验证码功能损坏

### 症状
- 用户点击注册
- 没有收到验证码邮件
- 或者验证码验证失败

### 可能的原因

1. **Resend API Key 未配置**
   - Railway 环境变量中没有 `RESEND_API_KEY`
   - 检查 `api.py` Line 91-98

2. **EMAIL_FROM 配置错误**
   - 发件人邮箱地址格式不对
   - Resend 要求特定格式

3. **数据库问题**
   - 验证码没有被保存到数据库
   - 检查 `auth_service.py` 的 `create_user()` 函数

### 调试步骤

1. **检查环境变量**:
```python
# api.py - Line 91-98
RESEND_API_KEY = os.getenv("RESEND_API_KEY")
EMAIL_FROM = os.getenv("EMAIL_FROM")

print(f"[DEBUG] RESEND_API_KEY configured: {bool(RESEND_API_KEY)}")
print(f"[DEBUG] EMAIL_FROM: {EMAIL_FROM}")

if not RESEND_API_KEY or not EMAIL_FROM:
    print("[WARN] Email sending disabled - missing config")
```

2. **检查邮件发送**:
```python
# api.py - register endpoint (Line 481-500)
try:
    create_user(payload.email, payload.password)
    print(f"[DEBUG] User created: {payload.email}")

    # 发送验证码邮件
    if RESEND_API_KEY and EMAIL_FROM:
        # ... 发送邮件 ...
        print(f"[DEBUG] Verification email sent to {payload.email}")
    else:
        print(f"[ERROR] Cannot send email - config missing")
except Exception as e:
    print(f"[ERROR] Registration failed: {e}")
    raise
```

3. **检查验证码生成和保存**:
```python
# auth_service.py - create_user 函数
def create_user(email: str, password: str) -> DbUser:
    verification_code = generate_verification_code()
    print(f"[DEBUG] Generated verification code: {verification_code} for {email}")

    user = DbUser(
        email=email,
        password_hash=hash_password(password),
        verification_code=verification_code,
        is_verified=False,
    )

    db.add(user)
    db.commit()
    db.refresh(user)

    print(f"[DEBUG] User saved to DB with code: {user.verification_code}")
    return user
```

### 解决方案

**临时方案**: 在开发环境中自动验证用户

⚠️ **安全警告**: 此方案有严重风险！务必确保：
- **只在显式的 dev-only 代码分支中使用**
- **在部署前检查 ENV 变量不会错误地设置成 development**
- **如果 ENV 变量配置错误，生产环境将自动验证所有用户，完全绕过邮箱验证**

```python
# api.py - register endpoint
# ⚠️ 危险：只应在本地开发环境使用
if os.getenv("ENV") == "development":
    print("[WARN] Development mode: auto-verifying user (NEVER use in production!)")
    user.is_verified = True
    db.commit()
    print(f"[DEV] Auto-verified user: {user.email}")
else:
    # 生产环境必须通过邮箱验证
    print(f"[PROD] User {user.email} requires email verification")
```

**更安全的实现**:
```python
# 显式检查，避免配置错误
IS_DEVELOPMENT = os.getenv("ENV") == "development" and os.getenv("ALLOW_AUTO_VERIFY") == "true"

if IS_DEVELOPMENT:
    print("[WARN] Auto-verification enabled (dev mode)")
    user.is_verified = True
    db.commit()
```

**生产方案**: 确保 Railway 环境变量配置正确

在 Railway 项目设置中添加：
```
RESEND_API_KEY=re_xxxxxxxxxxxxx
EMAIL_FROM=noreply@cyber1924.com
ENV=production
```

**⚠️ 部署前安全检查清单**:
1. ✅ 检查代码中**没有硬编码** `ENV=development`
2. ✅ 确认 Railway 环境变量设置为 `ENV=production`
3. ✅ 验证开发环境自动验证代码**只在明确的 if 块内**
4. ✅ 本地测试：设置 `ENV=production` 并确认**不会**自动验证
5. ✅ 部署后测试：尝试注册新用户，确认**必须**输入验证码

**危险示例** (❌ 绝对不要这样写):
```python
# ❌ 危险：默认自动验证，除非明确设置 production
if os.getenv("ENV") != "production":
    user.is_verified = True
```

**安全示例** (✅ 正确做法):
```python
# ✅ 安全：默认需要验证，只在明确 development 时才自动验证
if os.getenv("ENV") == "development":
    user.is_verified = True
```

---

## 问题 5: CORS 错误 - 前端无法连接后端

### 症状
- 控制台显示多个 CORS 错误
- 所有 `/sessions` 和 `/auth` 请求被阻止
- 错误信息: "No 'Access-Control-Allow-Origin' header is present"

### 根本原因

**文件**: `api.py`

**当前 CORS 配置** (Line 66-85):
```python
origins = [
    "http://localhost:5173",
    "http://localhost:5174",
    "https://cyber1924.com",
]

origin_regex = r"https://([a-zA-Z0-9-]+\.)?cyber1924\.pages\.dev|https://cyber1924-production\.up\.railway\.app"
```

**问题**: Cloudflare Pages 的实际 URL 可能不匹配 regex

### 调试步骤

1. **检查实际的 Origin**:
在浏览器控制台查看失败请求的 Origin 头：
```
Request URL: https://cyber1924-production.up.railway.app/sessions
Origin: https://cyber1924-xxx.pages.dev
```

2. **测试 CORS 响应**:
```bash
curl -H "Origin: https://cyber1924.pages.dev" \
     -H "Access-Control-Request-Method: GET" \
     -H "Access-Control-Request-Headers: Authorization" \
     -X OPTIONS \
     https://cyber1924-production.up.railway.app/sessions
```

应该返回:
```
Access-Control-Allow-Origin: https://cyber1924.pages.dev
Access-Control-Allow-Credentials: true
Access-Control-Allow-Methods: DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT
Access-Control-Allow-Headers: Authorization
```

如果没有返回这些头，或者 `Allow-Origin` 不匹配，说明 CORS 配置有问题。

### 解决方案

**方案 A: 更新 CORS regex - 使用安全的模式** (✅ 推荐)

⚠️ **安全警告**: 原先建议的 `.*` 模式太宽松，有域名欺骗风险！

**不安全的做法** (❌ 不要使用):
```python
# ❌ 危险：.* 可以匹配任意字符，包括恶意域名
# 例如: https://evil-cyber1924.pages.dev 也会匹配
origin_regex = r"https://.*\.cyber1924\.pages\.dev"
```

**安全的做法** (✅ 推荐):
```python
# api.py - Line 74-76
# ✅ 安全：只匹配字母、数字、连字符的子域名
origin_regex = r"https://([a-z0-9-]+\.)?cyber1924\.pages\.dev|https://cyber1924-production\.up\.railway\.app"
```

**说明**:
- `[a-z0-9-]+` 只匹配合法的子域名字符（小写字母、数字、连字符）
- `?` 使子域名部分可选，匹配 `cyber1924.pages.dev` 和 `xxx.cyber1924.pages.dev`
- 避免了 `.*` 的安全隐患

**部署后验证** (⚠️ 必须执行):
```bash
# 测试主域名
curl -I -H "Origin: https://cyber1924.pages.dev" \
     https://cyber1924-production.up.railway.app/sessions

# 测试子域名（如 main 分支）
curl -I -H "Origin: https://main.cyber1924.pages.dev" \
     https://cyber1924-production.up.railway.app/sessions

# 预期输出应该包含：
# Access-Control-Allow-Origin: https://cyber1924.pages.dev
# Access-Control-Allow-Credentials: true
```

如果没有看到 `Access-Control-Allow-Origin` 头，说明 regex 不匹配，需要调整模式。

**更严格的模式** (如果子域名命名规则固定):
```python
# 如果 Cloudflare Pages 只使用特定前缀（如分支名）
origin_regex = r"https://(main|dev|staging|[a-f0-9]{7})\.cyber1924\.pages\.dev|https://cyber1924\.pages\.dev|https://cyber1924-production\.up\.railway\.app"
```

**方案 B: 添加具体的 origin** (✅ 最安全)

如果部署 URL 固定，直接添加到白名单：

```python
origins = [
    "http://localhost:5173",
    "http://localhost:5174",
    "https://cyber1924.com",
    "https://cyber1924.pages.dev",
    "https://main.cyber1924.pages.dev",  # 主分支部署
    # 添加其他已知的部署 URL
]
```

**优点**: 最安全，完全控制允许的域名
**缺点**: 每次新增部署环境需要手动更新

**方案 C: 开发环境允许所有 origin** (⚠️ 仅用于本地测试)

```python
if os.getenv("ENV") == "development":
    print("[WARN] Development mode: allowing all CORS origins")
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )
else:
    # 生产环境使用严格的 CORS 配置
    app.add_middleware(
        CORSMiddleware,
        allow_origins=origins,
        allow_origin_regex=origin_regex,
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )
```

---

## 关键架构和安全原则

### 1. 治本 vs. 治标 (Root Cause vs. Symptoms)
- ❌ **治标不治本**: 在前端添加延迟、使用内存缓存绕过持久化失败
- ✅ **根本解决**: 修复后端状态管理、修复 envelope 写入逻辑

**教训**:
- 症状修复可能短期有效，但会导致不稳定、难以维护的系统
- 应优先寻找并修复根本原因，即使需要更多工作

### 2. 数据持久化 vs. 内存缓存 (Persistence vs. Cache)
- ❌ **依赖内存缓存**: 进程重启后数据丢失，不符合事件溯源原则
- ✅ **持久化优先**: 确保 envelope 正确写入，缓存只作为性能优化

**教训**:
- 事件溯源（Event Sourcing）系统必须保证日志完整性
- 缓存可以提升性能，但不能替代持久化存储

### 3. 安全配置的防御性编程 (Defensive Security Configuration)
- ❌ **宽松的模式**: `.*` 匹配任意字符，有域名欺骗风险
- ❌ **隐式依赖**: 依赖单一环境变量 `ENV == "development"`
- ✅ **显式验证**: 使用严格的正则表达式 `[a-z0-9-]+`
- ✅ **多重检查**: 要求多个条件同时满足（如 `ENV` + `ALLOW_AUTO_VERIFY`）

**教训**:
- 安全配置应该是白名单而不是黑名单
- 危险操作（如跳过验证）应该需要显式的多重确认
- 环境变量配置错误可能导致严重的安全漏洞

### 4. 前后端职责分离 (Frontend-Backend Separation)
- ❌ **前端控制流程**: 前端在异步更新后导航，导致状态不一致
- ✅ **后端控制流程**: 后端在创建 session 时就设置好所有状态，前端只展示

**教训**:
- 状态管理应该主要在后端，前端主要负责展示
- 前端的异步操作会引入竞态条件和不可预测性
- 简化前端逻辑可以提高系统的可靠性

---

## 修复优先级

### P0 - 阻塞性问题（必须立即修复）
1. **问卷流程乱跳** (问题 1) - 用户无法正常使用
   - 推荐方案: **方案B (后端自动锁定)**
   - 理由: 治本，避免前端状态不稳定

2. **CORS 错误** (问题 5) - 阻止所有 API 调用
   - 推荐方案: **方案A (安全的 regex)** 或 **方案B (白名单)**
   - 理由: 简单快速，注意安全模式

### P1 - 重要问题（尽快修复）
3. **Worker outputs empty** (问题 3) - 影响功能展示和数据完整性
   - 推荐方案: **方案B (修复 envelope 写入)** + 方案A作为补充
   - 理由: 保证数据持久化，避免重启后丢失

4. **注册验证码** (问题 4) - 阻止新用户注册
   - 推荐方案: **生产方案 (配置 Resend)** + 开发环境 fallback
   - 理由: 注意环境变量安全配置

### P2 - 可选改进
5. **Reviewer 滚动** (问题 2) - 可以通过其他方式查看内容
   - 推荐方案: **移除所有 overflow:hidden**
   - 理由: 纯 CSS 问题，不影响核心功能

---

## 修复顺序建议

### 第一轮：快速修复阻塞性问题
1. **修复 CORS** (5-10分钟)
   - 更新 [api.py:74-76](api.py#L74-L76) 的 `origin_regex`
   - 使用安全的模式: `r"https://([a-z0-9-]+\.)?cyber1924\.pages\.dev..."`
   - 本地测试，部署到 Railway

2. **修复问卷流程** (30分钟 - 1小时)
   - 实施方案B: 在 [run_flow.py:1588](multi_agent_platform/run_flow.py#L1588) 后添加 `state.plan_locked = True`
   - 本地测试完整 novel mode 流程
   - 确保不会再跳转回 planner
   - 提交并部署

### 第二轮：修复数据完整性问题
3. **修复 Worker outputs** (1-2小时，需要调试)
   - 在 [run_flow.py](multi_agent_platform/run_flow.py) 中添加详细的调试日志
   - 找到为什么 envelope 没有被写入
   - 添加错误处理和重试逻辑
   - 可选：添加内存缓存作为临时补充
   - 本地测试，确保 envelopes.jsonl 正确记录
   - 提交并部署

### 第三轮：配置和 UI 改进
4. **修复验证码** (30分钟 - 1小时)
   - 检查 Railway 环境变量 `RESEND_API_KEY` 和 `EMAIL_FROM`
   - 添加开发环境 fallback（注意安全配置）
   - 测试邮件发送
   - 提交并部署

5. **修复滚动** (15-30分钟)
   - 在 [App.tsx](multi_agent_platform/ui/src/App.tsx) 中移除所有 `overflow: hidden`
   - 测试 Reviewer 面板滚动
   - 提交并部署

---

## 测试清单

每次修复后必须测试：

- [ ] 能否注册新用户
- [ ] 能否登录
- [ ] 能否查看 session 列表
- [ ] 能否创建新 session
- [ ] Novel mode 问卷流程是否正常
- [ ] Plan 确认后是否正确进入执行页面
- [ ] Worker 是否显示输出
- [ ] Reviewer 是否可以滚动
- [ ] 所有功能是否没有 CORS 错误

---

## 回滚计划

如果修复失败，回滚到已知工作版本：

```bash
# 找到最后一个工作的 commit
git log --oneline --before="2025-12-10 09:00"

# 回滚到 0dd2460 (Fix CORS configuration)
git reset --hard 0dd2460

# 强制推送
git push --force
```

**最后工作的版本**: commit `0dd2460` - "Fix CORS configuration to support all Cloudflare Pages subdomains"

---

## 总结

当前系统有多个相互关联的问题，需要**系统性地逐个修复**，而不是同时修改多个地方。

**建议的修复流程**:
1. 先修复 CORS（阻塞所有功能）
2. 确认前端可以连接后端
3. 然后修复问卷流程
4. 最后修复显示问题（worker outputs, 滚动）

**不要做的事情**:
- ❌ 不要同时修改前端和后端
- ❌ 不要在没有测试的情况下提交
- ❌ 不要尝试一次性修复所有问题
- ❌ 不要修改部署配置（nixpacks, Procfile等）除非确定有问题

**每次修复的步骤**:
1. 只修改一个文件或一个问题
2. 本地测试
3. 提交（带详细说明）
4. 推送
5. 等待部署
6. 验证修复
7. 再修复下一个问题
