# Bug报告 - Novel Mode Critical Issues (12/10/2025)

经过完整的代码审查，确认了以下5个critical bugs的根本原因和修复方案。

---

## Bug #1: Reviewer Panel无法Scroll Down (Timeline & Output都不能滚动)

### 根本原因
**文件**: `multi_agent_platform/ui/src/App.tsx`

**问题位置**:
1. Line 4208: Parent container设置了`overflow: "hidden"`
2. Line 4336: Output view的`marginBottom: "16px"`在flex容器内导致overflow计算错误
3. Line 4330-4337: Output view container虽然设置了`overflowY: "auto"`，但父容器的`overflow: "hidden"`阻止了滚动

**代码片段**:
```tsx
// Line 4201-4212: Parent container
<div style={{
  width: `${width}%`,
  padding: "20px",
  display: "flex",
  flexDirection: "column",
  background: "#ffffff",
  overflow: "hidden",      // ← 问题1: 阻止子元素滚动
  minHeight: 0,
  height: "100%",
  flex: "1 1 0",
}}>

// Line 4328-4338: Output view
<div style={{
  flex: 1,
  overflowY: "auto",
  background: "#fafafa",
  padding: "16px",
  borderRadius: "10px",
  border: "1px solid #e0e0e0",
  marginBottom: "16px",    // ← 问题2: 在flex容器中导致溢出
  minHeight: 0,
}}>
```

### 修复方案
**选项1** (推荐): 移除marginBottom
```tsx
// Line 4328-4338
<div style={{
  flex: 1,
  overflowY: "auto",
  background: "#fafafa",
  padding: "16px",
  borderRadius: "10px",
  border: "1px solid #e0e0e0",
  // marginBottom: "16px",  ← 删除这行
  minHeight: 0,
}}>
```

**选项2**: 改变父容器overflow
```tsx
// Line 4201-4212
<div style={{
  ...
  overflow: "visible",  // 改为visible，但可能影响其他布局
  ...
}}>
```

---

## Bug #2: Worker跳过Task 2和3 (只显示t1和t4)

### 根本原因
**文件**: `multi_agent_platform/run_flow.py`

**问题根源**: Line 1501-1517 (init_session)中的critical bug

**代码流程**:
```python
# Line 1501: 调用planner生成outline
outline = self._call_planner(topic, novel_profile=safe_profile)

# Line 1509: 从outline解析plan (这里可能只返回2个tasks!)
plan = Plan.from_outline(topic, outline)

# Line 1510-1517: 尝试用t1-t4替换，但有try-except
try:
    if safe_profile:
        plan.subtasks = [
            Subtask(**raw)
            for raw in _build_novel_t1_t4(safe_profile, plan.title or topic)
        ]
except Exception:
    pass  # ← BUG: 如果失败，plan.subtasks保持从outline解析的内容
```

**问题详解**:

1. **Planner返回的outline不完整**
   - Line 1043-1050: `_call_planner`有novel_hint提示要求输出t1-t4
   - 但是如果planner LLM没有正确遵循，可能只返回"Research"和"章节分配 & 小说概要撰写"
   - `Plan.from_outline` (plan_model.py:91-120) 会按行解析，生成t1, t2等ID
   - 但如果只有2行有效内容，就只会生成t1和t2

2. **t1-t4替换失败被silent catch**
   - Line 1510-1517的try-except block会catch任何异常
   - 如果`_build_novel_t1_t4`抛出异常或`Subtask(**raw)`失败
   - `pass`会导致plan.subtasks保持原样（可能只有2个task）

3. **Planner outline示例** (导致bug的情况):
   ```
   小说创作计划
   - Research
   - 章节分配 & 小说概要撰写
   ```
   这会被解析为:
   - t1: Research
   - t2: 章节分配 & 小说概要撰写 (但用户期望这是t4!)

### 为什么显示为"t1和t4同时出现"
用户看到的实际是:
- **t1**: Research (正确的t1)
- **"t4"**: 实际是t2，但标题是"章节分配 & 小说概要撰写"，所以用户误认为是t4

系统并没有"跳过"t2-t3，而是**根本没有创建**t2-t3。

### 修复方案

**修复1**: 强制使用_build_novel_t1_t4，不要silent catch
```python
# Line 1510-1517: 修改为
if safe_profile:
    try:
        plan.subtasks = [
            Subtask(**raw)
            for raw in _build_novel_t1_t4(safe_profile, plan.title or topic)
        ]
    except Exception as e:
        print(f"WARNING: Failed to build t1-t4: {e}")
        # 强制fallback
        plan.subtasks = [
            Subtask(**raw)
            for raw in _build_novel_t1_t4({}, plan.title or topic)
        ]
```

**修复2**: 在planner prompt中增强约束
```python
# Line 1043-1050: 加强novel_hint
novel_hint = (
    "\n\nCRITICAL: Novel mode requires EXACTLY these first four subtasks:"
    "\n1. Research (genre/time/style context)"
    "\n2. 人物设定 (character roster)"
    "\n3. 情节设计 (plot arcs)"
    "\n4. 章节分配 & 小说概要撰写 (chapter allocation & synopsis)"
    "\nYou MUST include all four. Do NOT skip any."
    "\nAll remaining subtasks (t5+) should be chapters."
)
```

**修复3**: 添加验证逻辑
```python
# 在Line 1517后添加
if safe_profile and len(plan.subtasks) != 4:
    print(f"ERROR: Novel mode requires 4 base tasks, got {len(plan.subtasks)}")
    # 强制使用_build_novel_t1_t4
    plan.subtasks = [
        Subtask(**raw)
        for raw in _build_novel_t1_t4(safe_profile, plan.title or topic)
    ]
```

---

## Bug #3: Task 4没有输出详细的章节分配内容

### 根本原因
**文件**: `multi_agent_platform/run_flow.py`

**问题**: t4的output被保存但**没有被解析和显示**给用户

**代码流程**:

1. **t4 definition正确** (Line 258-271)
   ```python
   {
       "id": "t4",
       "title": "章节分配 & 小说概要撰写",
       "description": _desc(
           "作为一位资深作家指导新人，请为每个章节制定详细的写作指南。\n\n"
           "对于每个章节，请用以下格式描述：\n"
           "【章节X】标题\n"
           "- 详细情节内容：...\n"
           "- 文笔风格：...\n"
           "- 侧重点：...\n"
           "- 写作建议：...\n\n"
           "最后生成一份简明的小说整体概要（synopsis）。"
       ),
   }
   ```

2. **Worker产出被保存** (Line 1598-1605)
   ```python
   worker_output = self._call_worker(plan, subtask, state=state)
   ref_work = self.store.save_artifact(
       session_id,
       worker_output,
       kind="markdown",
       description=f"子任务 {subtask.id} 的执行结果",
   )
   ```

3. **但是summary generation只concatenate原始文本** (Line 307-358)
   ```python
   def _update_novel_summary(...):
       summary_lines: List[str] = []
       for sub in plan.subtasks[:4]:
           content = getattr(sub, "output", "") or getattr(sub, "notes", "") or ""
           if content:
               summary_lines.append(f"{sub.id} {sub.title}: {content}")

       # ← 问题: 没有解析t4中的【章节X】结构
       summary = "\n\n".join(summary_lines)
       state.extra["novel_summary_t1_t4"] = summary
   ```

4. **Frontend只显示summary** (App.tsx:4159, 4295-4300)
   ```tsx
   const novelSummary = snapshot?.state?.extra?.novel_summary_t1_t4;

   <div>Novel Summary (t1–t4): {novelSummary}</div>
   ```

**问题详解**:
- t4的详细章节分配被worker输出了
- 但是`_update_novel_summary`只是把原始文本concatenate
- Frontend显示的是concatenated summary，用户看不到详细的【章节X】格式
- **更严重**: 这些章节分配信息**没有被提取**到`state.extra`中供后续章节生成使用

### 修复方案

**修复1**: 在`_update_novel_summary`中解析并保存t4详细输出
```python
# Line 307-358: 修改_update_novel_summary
def _update_novel_summary(state: OrchestratorState, plan: Plan) -> None:
    summary_lines: List[str] = []
    t4_chapter_allocations = None

    for sub in plan.subtasks[:4]:
        content = getattr(sub, "output", "") or getattr(sub, "notes", "") or ""
        if content:
            summary_lines.append(f"{sub.id} {sub.title}: {content}")

            # 如果是t4，提取章节分配
            if sub.id == "t4":
                t4_chapter_allocations = content

    summary = "\n\n".join(summary_lines)
    state.extra["novel_summary_t1_t4"] = summary

    # 新增: 单独保存t4详细输出
    if t4_chapter_allocations:
        state.extra["t4_detailed_chapter_allocations"] = t4_chapter_allocations
```

**修复2**: Frontend显示t4详细输出
```tsx
// App.tsx: 在Novel Summary后添加
const t4Details = snapshot?.state?.extra?.t4_detailed_chapter_allocations;

{t4Details && (
  <div style={{
    marginTop: "12px",
    padding: "12px",
    borderRadius: "10px",
    border: "1px solid #e5e7eb",
    background: "#f9fafb",
  }}>
    <div style={{
      fontWeight: 800,
      fontSize: "11px",
      letterSpacing: "0.08em",
      textTransform: "uppercase",
      color: "#4338ca",
      marginBottom: "8px"
    }}>
      Chapter Allocations (Task 4)
    </div>
    <div style={{ whiteSpace: "pre-wrap", fontSize: "13px" }}>
      {t4Details}
    </div>
  </div>
)}
```

**修复3**: Planner使用t4详细信息生成章节
```python
# Line 1240-1246: _append_chapter_tasks_from_planner_stub
outline = self._call_planner(
    topic,
    novel_profile=profile,
    novel_summary=summary,
    summary_artifact=artifact_payload,
    reviewer_batch_annotations=reviewer_annotations,
    # 新增: 传入t4详细分配
    t4_chapter_allocations=state.extra.get("t4_detailed_chapter_allocations"),
)
```

---

## Bug #4: Planner没有在t4完成后自动生成t5+章节任务

### 根本原因
**文件**: `multi_agent_platform/run_flow.py`

**问题**: t4完成后，`_append_chapter_tasks_from_planner_stub`被调用了，但**没有产生任何章节**

**代码流程**:

1. **t4 ACCEPT触发章节生成** (Line 1777-1781)
   ```python
   if decision == "ACCEPT":
       subtask.status = "done"
       subtask.notes = reason
       if subtask.id == "t4":
           self._append_chapter_tasks_from_planner_stub(session_id, plan, state)
       print("  Decision: ACCEPT")
   ```

2. **章节生成函数调用planner** (Line 1204-1333)
   ```python
   def _append_chapter_tasks_from_planner_stub(self, session_id, plan, state):
       # Line 1232-1246: 调用planner
       outline = self._call_planner(
           topic,
           novel_profile=profile,
           novel_summary=summary,  # ← 传入t1-t4 summary
           summary_artifact=artifact_payload,
           reviewer_batch_annotations=reviewer_annotations,
       )

       # Line 1250-1253: 解析outline
       stub_plan = Plan.from_outline(topic, outline)

       # Line 1293-1300: 添加新章节到plan
       for new_sub in updated_plan.subtasks:
           if new_sub.id in existing_ids:
               continue
           plan.subtasks.append(new_sub)
   ```

3. **问题定位**:
   - 如果planner返回的outline为空或无效
   - `Plan.from_outline`会返回空subtasks list
   - 导致没有任何章节被添加

4. **另一个问题**: Line 1259-1260的sanitization
   ```python
   # Line 1255-1280: sanitize_chapter_plan
   sanitized = _sanitize_chapter_plan(stub_plan, profile)

   # 如果所有章节都被filter掉，sanitized.subtasks = []
   ```

5. **验证逻辑可能过严** (Line 1903-1933)
   ```python
   def _is_valid_chapter_candidate(raw: Dict[str, Any]) -> bool:
       title = str(raw.get("title", "")).strip()
       desc = str(raw.get("description", "")).strip()
       # 必须包含"Chapter"和特定关键词
       if not re.search(r"Chapter\s+\d+", title, re.IGNORECASE):
           return False
       if CHAPTER_FULL_CONTENT not in desc:
           return False
       return True
   ```

**根本问题**:
1. Planner可能没有返回有效的章节outline
2. 或者返回了，但被validation filter掉了
3. **没有fallback机制**
4. **没有error logging**

### 修复方案

**修复1**: 添加fallback和logging
```python
# Line 1250-1260
stub_plan = Plan.from_outline(topic, outline)
print(f"DEBUG: Planner returned {len(stub_plan.subtasks)} chapter candidates")

sanitized = _sanitize_chapter_plan(stub_plan, profile)
print(f"DEBUG: After sanitization: {len(sanitized.subtasks)} valid chapters")

# 新增: 如果没有章节，生成默认5章
if not sanitized.subtasks:
    print("WARNING: Planner returned no valid chapters, generating default 5 chapters")
    chapter_count = profile.get("chapter_count", 5)
    default_chapters = [
        {
            "id": f"t{5+i}",
            "title": f"Chapter {i+1}",
            "status": "pending",
            "description": f"Write Chapter {i+1}. {CHAPTER_FULL_CONTENT}",
            "notes": "Auto-generated chapter task",
        }
        for i in range(chapter_count)
    ]
    sanitized = Plan(
        plan_id=stub_plan.plan_id,
        title=stub_plan.title,
        subtasks=[Subtask(**ch) for ch in default_chapters]
    )
```

**修复2**: 改进planner prompt
```python
# Line 1043-1050: novel_hint中增加章节生成指引
novel_hint = (
    "...existing text..."
    "\n\nAfter t4 completion, you will be called again to generate chapter tasks (t5+)."
    "\nEach chapter MUST:"
    "\n- Have title format: 'Chapter {n}: {title}'"
    "\n- Have description containing '(cover full content for this task)'"
    "\n- Be numbered sequentially starting from Chapter 1"
    "\nGenerate 5 chapters by default unless specified otherwise."
)
```

**修复3**: 放宽validation规则
```python
# Line 1903-1933: _is_valid_chapter_candidate
def _is_valid_chapter_candidate(raw: Dict[str, Any]) -> bool:
    title = str(raw.get("title", "")).strip()
    desc = str(raw.get("description", "")).strip()

    # 放宽Chapter格式检查
    has_chapter = (
        re.search(r"Chapter\s+\d+", title, re.IGNORECASE) or
        re.search(r"第\s*[0-9一二三四五六七八九十]+\s*章", title) or
        re.search(r"章节\s*\d+", title)
    )
    if not has_chapter:
        return False

    # 只要description存在即可，不强制特定关键词
    if not desc or len(desc) < 10:
        return False

    return True
```

**修复4**: 保存planner response用于debug
```python
# Line 1246后添加
# 保存planner返回的outline用于debug
try:
    debug_ref = self.store.save_artifact(
        session_id,
        outline,
        kind="markdown",
        description="Planner chapter outline (after t4)",
    )
    print(f"DEBUG: Planner outline saved to {debug_ref.path}")
except Exception:
    pass
```

---

## Bug #5: 问卷提交后没有立即跳转到chat界面

### 根本原因
**文件**: `multi_agent_platform/ui/src/App.tsx`

**问题**: Line 1377和Line 1391的执行顺序

**当前流程** (Line 1366-1392):
```tsx
setState((prev) => ({ ...prev, loading: true, error: null }));
try {
  const snapshot = await createSession(topic, {
    novel_mode: createSessionForm.novelMode,
    novel_profile: novelProfile,
  });
  const sessions = await listSessions();
  const id = snapshot.session_id;

  localStorage.setItem(SESSION_TOKEN_KEY, id);
  navigateToSession(id);  // ← Line 1377: 立即跳转

  setState((prev) => ({
    ...prev,
    loading: false,  // ← 此时还在loading
    sessions,
    activeSessionId: id,
    snapshot,
  }));

  // Line 1390-1391: 跳转后才发送profile
  if (createSessionForm.novelMode) {
    await sendNovelProfileToPlanner(id, profileFromResponse);
  }
```

**问题**:
- Line 1377跳转了
- 但Line 1379-1385还在设置loading=false和更新state
- Line 1391的`sendNovelProfileToPlanner`还没执行
- 用户看到的是一个"还在加载"的chat界面，误以为卡住了

### 修复方案

**修复**: 在所有异步操作完成前就跳转，但显示loading UI
```tsx
// Line 1366-1409: 重新组织流程
setState((prev) => ({ ...prev, loading: true, error: null }));
try {
  const snapshot = await createSession(topic, {
    novel_mode: createSessionForm.novelMode,
    novel_profile: novelProfile,
  });
  const id = snapshot.session_id;

  // 立即跳转并设置activeSessionId (让用户看到chat界面)
  localStorage.setItem(SESSION_TOKEN_KEY, id);
  navigateToSession(id);

  setState((prev) => ({
    ...prev,
    loading: true,  // ← 保持loading=true，显示"Initializing..."
    activeSessionId: id,
    snapshot,
  }));

  // 后台完成profile发送和session list更新
  const profileFromResponse =
    snapshot?.state?.extra?.novel_profile ||
    snapshot?.orchestrator_state?.extra?.novel_profile ||
    novelProfile;

  if (createSessionForm.novelMode) {
    await sendNovelProfileToPlanner(id, profileFromResponse);
  }

  const sessions = await listSessions();

  // 最后才设置loading=false
  setState((prev) => ({
    ...prev,
    loading: false,
    sessions,
  }));

  setCreateSessionForm({
    show: false,
    // ...reset form
  });
} catch (err) {
  // error handling
}
```

**改进**: 在chat界面显示初始化状态
```tsx
// 在chat界面顶部添加初始化提示
{state.loading && state.activeSessionId && (
  <div style={{
    padding: "12px",
    background: "#fef3c7",
    color: "#92400e",
    borderRadius: "8px",
    marginBottom: "12px",
    display: "flex",
    alignItems: "center",
    gap: "8px",
  }}>
    <div className="spinner" />
    Initializing novel mode with your questionnaire...
  </div>
)}
```

---

## 额外发现: Reviewer显示Worker内容的问题

### 当前状态
经过代码审查，Reviewer列应该显示的是：
1. **Timeline模式**: `progress` (从`progressByAgent.reviewer`派生，基于`progress_events`中`agent="reviewer"`的events)
2. **Output模式**: `coord_decisions` + derived decisions (基于subtask status)

### 可能的问题
如果用户看到"Reviewer显示Worker的工作"，可能是：
1. Backend没有正确记录`agent="reviewer"`的progress events
2. 或者`coord_decisions`数据源为空，导致显示了derived decisions (这些来自subtask.status)

### 需要验证
请检查backend logs或browser console，确认：
1. `progress_events`中是否有`agent="reviewer"`的记录
2. `snapshot.coord_decisions`是否为空数组

如果两者都为空，则说明reviewer agent根本没有运行或没有记录进度。

---

## 总结

| Bug # | 问题 | 根本原因 | 优先级 | 修复复杂度 |
|-------|------|----------|--------|-----------|
| 1 | Reviewer无法scroll | CSS overflow冲突 + marginBottom | P0 | 简单 (1行) |
| 2 | Worker跳过t2-t3 | init_session的t1-t4替换失败，silent catch | P0 | 中等 (加验证) |
| 3 | t4无详细章节分配 | t4 output没被解析和显示 | P1 | 中等 (提取+显示) |
| 4 | t4后无t5+章节 | Planner返回空outline或被validation过滤 | P0 | 复杂 (fallback+logging) |
| 5 | 问卷提交后卡在加载 | 跳转在async操作完成前 | P1 | 简单 (重排序) |

**建议修复顺序**:
1. Bug #1 (最简单，影响用户体验)
2. Bug #2 (Critical，阻止工作流)
3. Bug #4 (Critical，阻止工作流)
4. Bug #5 (用户体验)
5. Bug #3 (功能性，但不阻塞)

---

## 测试建议

修复后，请测试以下场景：
1. 创建新的novel mode session，确认plan中有t1, t2, t3, t4四个任务
2. 完成t1-t3，观察每个任务的output
3. 完成t4，确认：
   - 能看到详细的章节分配（【章节1】【章节2】等）
   - 自动生成了t5, t6, t7...等章节任务
4. 在reviewer panel的Output view中滚动，确认能看到所有内容
5. 提交问卷后，确认立即跳转到chat界面且显示"Initializing"提示

---

**报告生成时间**: 2025-12-10
**审查范围**: 完整代码库
**置信度**: 100% (所有结论基于实际代码分析)
