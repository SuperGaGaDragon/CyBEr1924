
***目标流程***
- 进入novel mode，用户输入问卷之后，planner生成t1-t4 （写死）
t1: Research 请给出对于这种文学体裁，时间背景，相关风格的研究报告。
description：用户前面输入的小说发生年份、小说题材、风格、小说题目
t2: 人物设定
description：用户前面输入的人物设定
t3: 情节设计
t4: 章节分配&小说概要撰写
description：1、生成前4个task的概要（简明但清晰）2、对每个章节些什么进行分配

- 进入正常的三栏式页面，worker， reviewer开始工作。
- worker把t4完成后，自动把t4内容上传给planner和reviewer。reviewer永久持有此份文档，以此为要求对后续的正式内容生成进行审查
- planner自动生成t5之后的sub task，强制要求一个task一个章节，要求输入完整内容。
- reviewer的（从t5之后）上下文打通为每3个task一个上下文，worker的3个task放在一起审核，然后把需要修改的地方的task对应的worker去修改。


***目前差距***
- `_call_planner` 只有 `novel_profile` 输入，永远不会收到 `novel_summary_t1_t4` 这份由 t1–t4 产出生成的具体摘要（见 `multi_agent_platform/run_flow.py` 约 760 行），所以在强制写完前四个任务后 planner 无法 “带着”那份研究/人物/情节的成果继续规划章节。
- t4 完成后没有自动触发 planner 重新生成 t5+，`run_next_pending_subtask` 只是顺序执行现有 plan，而新的章节任务只有依赖初始 Planner 直接输出或者用户主动修改计划，未满足“t4 完结立即继续生成章节”的流。
- `_apply_planner_result_to_state` 和 `generate_stub_plan_from_planning_input` 只是把已经存在的后续 subtasks 用 `_chapter_title/_chapter_description` 包装，而没有额外验证或 guardrail 确保“每个新任务就是一个章节，必须写完整内容”。
- Reviewer 每次只处理一个子任务、`reviewer_batch_counter` 也在 `_call_coordinator` 里每 5 次才归零，并不会按照目标流程里 “t5+ 按 3 个任务为一组进行审核、然后再递给需要修改的 worker” 来办理。
- “worker 把 t4 内容上传给 planner/reviewer，reviewer 永久持有 t4 文档” 目前只是把摘要缓存到 `state.extra`，未同步写入 artifact，也没在后续 planner prompt 中主动引用，所以续写章节时并未真正“重用”这份 t4 成果。
- 调度仍然是 subtask → review → redo 的单条流水，reviewer 也不会把成组正文一次性打包回传给 worker，缺失目标流程里 reviewer 发现问题后明确指向每个章节/worker 的反馈闭环。

***落地方案***
每完成一个内容就在[]中打x
phase1 — 确保 t1–t4 产出可重用
- [x] 1.1: 修改 `_update_novel_summary`（`multi_agent_platform/run_flow.py` 约 262 行），每次从 plan.subtasks[:4] 中生成摘要后同时写入 ArtifactStore (`Orchestrator._record_progress_event`/`worker` 保存后的 Artifact)，并把 artifact_ref 存入 `state.extra["novel_summary_artifact"]`。
- [x] 1.2: 把 `_call_planner` 的 prompt 构造（`Orchestrator._call_planner`）扩展成 `context + profile + summary`，其中 `context` 取自 `state.extra["novel_summary_t1_t4"]`（若存在）并附上 artifact link，这样真实 planner/stub planner 在生成 t5+ 时已经具有前四个任务的完整上下文。
- [x] 1.3: 在 `_novel_extra_context` 里加入 summary/artifact info 作为 extra_context 供 worker/coordinator 参考，确保 reviewer 以及 worker 能“看到”那份 t4 文本（不只是 profile 字段）。

phase2 — 完成 t4 后自动驱动章节生成
- [x] 2.1: 在 `run_next_pending_subtask` 的 worker loop 每次 `subtask.id == "t4"` 且 `decision == "ACCEPT"` 后，通过 `_call_planner`（传 `state.extra["novel_summary_t1_t4"]`）重新生成 plan stub、调用 `_apply_planner_result_to_state`，把新增的 t5+ 章节拼入 plan（避免重复 id）。
- [x] 2.2: 把 `_record_progress_event`/`Orchestrator._persist_plan_state` 中新增 `state.extra["novel_phase_step"]`（记录已补充章节数量），用于后续验证“t4 之后至少有 3 个 Chapter 任务”。
- [x] 2.3: 给 `generate_stub_plan_from_planning_input` 增加 `chapter_batch_size` 参数，默认每次调用 append 三个 `Chapter` 子任务；当用户主动补充（/plan）也复用同一入口，保持行为一致。

phase3 — 强制后续任务就是章节
- [x] 3.1: 提取 `_normalize_chapter_subtask(raw: dict, index: int)`，包装 `_chapter_title`/`_chapter_description`/`CHAPTER_FULL_CONTENT`，把所有 `raw` subtasks（planner result + stub append）统一过该函数，生成 `title`, `description`, `id`。
- [x] 3.2: 在 `_apply_planner_result_to_state` 和 `generate_stub_plan_from_planning_input` 中加入校验，如果 `raw.get("description")` 里缺失 `CHAPTER_FULL_CONTENT` 或 `raw.get("title")` 不包含 `Chapter {n}`，则在 `plan.notes` 追加 warning 信息并跳过该 task（防止 planner 生成非章节内容）。
- [x] 3.3: 更新 `Plan.from_outline`/`Plan` 数据结构（若需要）以便可读性地标注章节 metadata（例如 `subtask.metadata["chapter_index"]`），方便 coordinator/worker 追踪哪几章是一组。

phase4 — Reviewer 按 3 个章节批次复核
- [x] 4.1: 让 `state.extra["reviewer_batch_counter"]` 记录当前批次数量，每次 review 一个 subtask 前先检查 `state.extra["reviewer_batch_tasks"]`（list），如果该 list 长度 < 3 则把当前 `subtask.id`/artifact 加入并等待，只有集齐 3 个后才调用 `_call_coordinator`；否则延后至分组完成再 review。
- [x] 4.2: `_call_coordinator` 要求 `extra_context` 包含三条 `worker_output` 摘要（可从 `state.extra["recent_worker_outputs"]` 读），并在 strict_novel_mode 下把 `novel_summary_t1_t4` + 当前 batch 书写进 prompt。
- [x] 4.3: 审核完毕（即 coordinator 回答后）重置 `state.extra["reviewer_batch_tasks"]`，但保留 `novel_summary_t1_t4`/artifact 和 `reviewer_batch_counter`（置为 `+1`），并将 reviewer output 编号为 `batch_{n}` 写入 `state.extra["reviewer_revisions"]`（key = subtask_id，value 包含 `batch_id` + revision text + optional artifact ref）。

phase5 — 让 reviewer 修订结果驱动 worker+planner
- [x] 5.1: `Orchestrator.execute_command("/apply_reviewer_revision")` 里除了替换 subtask.output，也应该把 `state.extra["novel_inflight_batch"]` 的 summary 再次注入 `_call_worker` 的 `extra_context`，让 worker 在重写时能参考 reviewer 原始意见 + t4 summary。
- [x] 5.2: 当 planner 在 phase2 重新运行时，除了 summary，还要把 `state.extra["reviewer_revisions_batch"]`（最新批次的批注）附加在 prompt 中，以保证后续章节写作遵循 reviewer 的批量反馈。
- [x] 5.3: 测试：扩展 `test_novel_mode.py` 让 `mock_coordinator_run` 依序在第 3 个任务后触发 reset、[1.2] 之后 assert planner prompt 包含 summary+artifact, [3.2] 断言非章节任务被 skip, [4.1] 读出 `state.extra["reviewer_batch_tasks"]` 和 `batch_id`，[5.1] 通过 `/apply_reviewer_revision` 验证 worker output 被覆盖且 summary 继续可见。
