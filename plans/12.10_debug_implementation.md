

# Debug Implementation Plan - 2025-12-10

## 当前问题概览

结合 `12.10_debug.md` 的现状分析和 `12.9debug.md` 中的历史信息，目前聚焦的阻塞点是：

1. ❌ **P0 - 401 Unauthorized / Not authenticated**（再现于 `sess-20251210-204413-3b9a091d`）：用户已登录但后端持续提示缺少凭证，前端已经确认 `setAccessToken`、`localStorage`、API 请求等代码段都存在，问题更可能在环境配置（API_BASE）或 token 在请求中未发送。
2. ⚠️ **P1 - Token 有效性 / 过期**：JWT 有效期 24 小时，`12.9debug.md` 提到过类似的 “失效” 问题，因此需要先验证是 token 过期还是根本没发送 Authorization 头。
3. ℹ️ **CORS / 部署域**: `12.9debug.md` 的 CORS 修复、Novel Mode 问卷跳转等已经完成，但它们的文档也提示：在不同域（railway / pages / 本地）切换时，`API_BASE` 变量必须同步，否则请求就会发到 `http://localhost:8000` 进而导致“Not authenticated”。

## 落地方案（按优先级排序）

每完成一个事情，在[] 内打✅


### Phase 1: 先定位、再动手

#### Step 1.1: 打开后端日志抓取真相
- **文件**: `api.py:109-128`
- [x] **目标**: 让 `get_current_user` 明确记录当前请求是“没带 header”还是“decode 失败”，避免盲修。
- **实施步骤**:
  1. [x] 输出 `credentials is None` 或 token 前缀（避免打印完整 token，打 `token[:20]`）；
  2. [x] 输出 `decode_access_token` 是否返回了 user_id，并把 user_id/logged-in state 记录到标准输出；
  3. [x] 如果 decode 成功但 `get_user_by_id` 失败，额外打印 user_id。
- **验证**:
  1. [] 在 Railway/Pages 上重现 `sess-20251210-204413-3b9a091d` 请求；
  2. [] 查看后端 stdout/structured log，确认请求有没有 Authorization header、token 是否解析成功。
- **预期时间**: 15-30 分钟
- **风险**: 极低（仅加日志）。

#### Step 1.2: 浏览器 DevTools + 环境变量检查
- **文件**: `multi_agent_platform/ui/src/api.ts:100-176`
- [] **目标**: 确保生产部署的请求真正发向后端，并附带 localStorage 中的 JWT。
- **实施步骤**:
  1. 在 `api.ts` 中记录 `API_BASE`、`accessToken` 是否设置（可用 `console.debug` 但避免泄露 token）；
  2. 检查 `import.meta.env.VITE_API_BASE_URL`：若为空或仍 `localhost`，将默认改为 `window.location.origin` + `/api`（或部署时必填 env）；
  3. 引导 QA 在 DevTools -> Network -> failed `/sessions/...` 请求里确认请求头包含 `Authorization: Bearer xxx`，并和 localStorage 里的 token 做比对；同时执行 `plans/12.10_debug.md` 的手动 fetch 验证脚本。
- **验证**:
  1. Browser console 显示 `API_BASE` 正确；
  2. 请求 `Authorization` 头与 localStorage 一致；
  3. 若 header 缺失，说明问题在于 base url / fetch 被阻止；若 header 存在但 response 401，则说明 token 过期。
- **预期时间**: 20-40 分钟
- **风险**: 低（更多是信息收集/确认）

### Phase 2: 根据定位结果修复

#### Step 2.1: 若确认 header 丢失 —— 固定 API_BASE & 访问域
- **原因**: 生产环境仍默认 `http://localhost:8000` 会被浏览器拦截，导致请求根本没有 Authorization header。
- []  **目标**: 将前端请求指向实际后端，确保 `fetch` 走可访问域，CORS 头也稳定。
- **实施步骤**:
  1. [] 修改 `api.ts` 定义 `const API_BASE = import.meta.env.VITE_API_BASE_URL || window.location.origin.replace(/\/+$/, "") + "/api"`（或需要的路径）；
  2.[]  确保部署流水线（Railway/Pages）里都设置了 `VITE_API_BASE_URL`，并在 README 里记录；
  3. [] 重新部署前端，检查 `console.log(API_BASE)` 在生产页面是否为目标 host；
  4. [] 再次用 DevTools 重现失败请求，确认请求发送至正确后端，Authorization header 不再被移除；
  5. [] 如果需要，配合 `plans/12.9debug.md` 中的 CORS 验证脚本确保 `Access-Control-Allow-Credentials` 与 `Authorization` 头共存。
- **验证**:
  - [] 成功请求 `/sessions` 返回 200（200 以上无需 token 过期）；
  - [] console network tab 显示请求目标 host 为 `cyber1924-production.up.railway.app`（或配置的域）；
  - [] 后端日志中对应请求打印的 token 前缀。
- **预期时间**: 30-60 分钟
- **风险**: 低（需要同步 env 配置，但仅配置/部署修改）。

#### Step 2.2: 若确认 header 存在但 token 无效 —— 增加刷新/延长策略
- **原因**: 401 报错提示 `Invalid or expired token`，说明 header 发出但 JWT 失效；`12.9debug.md` 提到过“token 生命周期太短”的问题。
- **目标**: [] 先在后端记录日志再决定后续策略，默认先延长有效期 + 增加刷新 endpoint。
- **实施步骤**:
  1. [] 临时延长 `JWT_EXPIRE_MINUTES`（如改为 7 天）以观察是否立刻缓解；
  2. [] 在 `api.py` 中新增 `/auth/refresh` endpoint（如 `plans/12.10_debug.md` 所述），需要提供当前 token；
  3. [] 在 `multi_agent_platform/ui/src/api.ts` 的 `request` 函数内检测 401：若不是刷新请求则先调用 `/auth/refresh`，获取新 token 并重试一次（要加 flag 防止递归）；将新 token 写回 `localStorage` + `setAccessToken`；
  4. 增加最大刷新尝试次数（比如 1 次）并在刷新失败后调用 `resetToLoggedOut`。
- **验证**:
  - 模拟过期 token，调用任意受保护接口，观察前端能否自动刷新并成功返回；
  - 后端日志中应该先打印刷新请求，再打印原始请求附带新 token；
  - 用户在 token 过期后不需要手动重新登录。
- **预期时间**: 1-2 小时（包含前后端联调）
- **风险**: 中（需防止刷新死循环、保护刷新端点）。

#### Step 2.3: 补充开发用快捷调试路径（可选）
- **目标**:  [] 给开发环境提供快速验证手段。
- **实施步骤**:
  1. [] 在 `api.py` 的开发路径中，确保 `get_db` 生成器存在，避免 `12.10_debug.md` 中“自动 verify 失败”的打印；
  2. [] 增加单元测试模拟 `get_current_user` 行为（如给定 header/无 header/过期 token）；
  3. [] 在 `plans/12.9debug.md` 中提到的 `localStorage.clear(); location.reload();` 这类临时处理可写入 `SESSION_RECOVERY_README.md` 作为排查 checklist。
- **预期时间**: 20-40 分钟
- **风险**: 低（内部工具改进）







## 实施注意事项

### 1. 一次只修复一个问题
- ❌ 不要同时修改前端和后端
- ❌ 不要在没有测试的情况下提交
- ❌ 不要尝试一次性修复所有问题
- ✅ 每次只修改一个文件或一个问题

### 2. 每次修复的步骤
1. 只修改一个文件或一个问题
2. 本地测试
3. 提交（带详细说明）
4. 推送
5. 等待部署
6. 验证修复
7. 再修复下一个问题

### 3. 治本 vs. 治标
- 优先实施"方案B"类型的根本解决方案
- 避免只修复症状而不解决根本原因
- 确保数据持久化而不是依赖内存缓存

### 4. 安全原则
- 使用白名单而不是黑名单
- 危险操作需要显式的多重确认
- 环境变量配置错误可能导致严重安全漏洞
- 部署前必须验证安全配置
